<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>無人店舗分析ツール</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- ライブラリ（CDN） -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    :root { --border:#e5e7eb; --muted:#6b7280; --ink:#111827; --bg:#fff; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif; margin:16px; color:var(--ink); background:var(--bg); }
    .card { border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:16px; background:#fff; }
    .btn { background:var(--ink); color:#fff; padding:10px 14px; border-radius:8px; border:none; cursor:pointer; display:inline-block; text-decoration:none; }
    .btn.secondary { background:#374151; }
    .btn.ghost { background:#fff; color:var(--ink); border:1px solid var(--border); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn-group { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    label { font-weight:700; display:block; margin-bottom:6px; }
    /* ファイル入力は“見えないだけ”。display:none は使わない */
    input[type="file"] {
      position: absolute;
      left: -9999px;
      width: 1px; height: 1px;
      opacity: 0;
    }
    .muted { color:var(--muted); font-size:12px; }
    .error { color:#b91c1c; font-weight:700; white-space:pre-wrap; }
    .metrics { display:flex; gap:12px; flex-wrap:wrap; margin:8px 0; }
    .metric { border:1px solid var(--border); border-radius:10px; padding:8px 12px; background:#fafafa; }
    .kpi-strong { font-weight:800; font-size:16px; }
    /* tabs */
    .tabs { display:flex; gap:8px; margin:12px 0; border-bottom:1px solid var(--border); flex-wrap:wrap; }
    .tab { padding:10px 12px; border:1px solid var(--border); border-bottom:none; border-radius:8px 8px 0 0; background:#f9fafb; cursor:pointer; }
    .tab.active { background:#fff; font-weight:700; }
    .tabcontent { display:none; }
    .tabcontent.active { display:block; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th, td { border-bottom:1px solid #eee; padding:6px 8px; text-align:left; }
    .diag { margin-top:8px; padding:8px 10px; border:1px dashed var(--border); border-radius:8px; background:#fafafa; }
    .fname { font-size:12px; padding:4px 8px; border:1px solid var(--border); border-radius:6px; background:#fafafa; }
    .fileline { display:flex; align-items:center; gap:8px; }
    .form-row { display:flex; gap:12px; flex-wrap:wrap; align-items:end; margin-bottom:12px; }
    .form-row > div { display:flex; flex-direction:column; gap:6px; }
    select, input[type="date"], input[type="text"] { padding:8px 10px; border:1px solid var(--border); border-radius:8px; min-width:160px; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:12px; background:#fafafa; }
    /* modal */
    .modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:1000; }
    .modal .dialog { background:#fff; width:min(720px, 92vw); margin:10vh auto; border-radius:12px; padding:16px 18px; border:1px solid var(--border); }
    .modal .close { float:right; cursor:pointer; font-weight:900; font-size:20px; padding:2px 8px; border-radius:8px; }
    .info-btn { border:1px solid var(--border); background:#fff; color:#111; border-radius:999px; width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; font-weight:800; }
    .info-btn:hover { background:#f3f4f6; }
    .hstack { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 900px){ .grid2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h1>無人店舗分析ツール</h1>
  <p class="muted">データはブラウザ内でのみ処理され、サーバーへ送信されません。（PC想定）</p>

  <!-- 取込UI -->
  <div class="card">
    <label style="margin-bottom:10px;">csv取り込み</label>

    <div class="btn-group" style="margin-bottom:6px;">
      <div class="fileline">
        <label for="txFile" class="btn">取引毎</label>
        <span id="fnameTx" class="fname muted">未選択</span>
      </div>

      <div class="fileline">
        <label for="lnFile" class="btn">商品毎</label>
        <span id="fnameLn" class="fname muted">未選択</span>
      </div>

      <div class="fileline">
        <label for="pmFile" class="btn secondary">商品マスタ取り込み(csv)</label>
        <span id="fnamePm" class="fname muted">未選択</span>
      </div>

      <span id="status" class="muted" style="margin-left:auto;">CSVを2つ選択してください</span>
    </div>

    <!-- 実体の file input（視覚的に隠してあるだけ） -->
    <input id="txFile" type="file" accept=".csv" />
    <input id="lnFile" type="file" accept=".csv" />
    <input id="pmFile" type="file" accept=".csv" />

    <div class="btn-group" style="margin-top:8px;">
      <button id="runBtn" class="btn" disabled>取り込み & 集計</button>
      <span id="catStatus" class="muted">カテゴリマスタ：起動時にGitHubから自動読込</span>
    </div>

    <p class="muted" style="margin-top:8px;">
      商品マスタCSVの列：<code>商品コード</code> / <code>商品分類</code> / <code>商品名</code>（<code>商品名規格</code>でも可）/ <code>POS原価</code>（ExcelのM列）
    </p>
  </div>

  <!-- タブ -->
  <div class="tabs">
    <div class="tab active" data-tab="previewTab">取り込みデータsummary</div>
    <div class="tab" data-tab="bestTab">ベスレポ集計</div>
    <div class="tab" data-tab="timeTab">時間帯集計</div>
    <div class="tab" data-tab="prodTab">単品分析</div>
    <div class="tab" data-tab="rfmTab">RFM分析</div>
    <div class="tab" data-tab="segTab">セグメント分析</div>
    <div class="tab" data-tab="repeatOnlyTab">リピート分析</div>
    <div class="tab" data-tab="pairOnlyTab">併売分析</div>
  </div>

  <!-- 取り込みデータsummary -->
  <div id="previewTab" class="tabcontent active">
    <div class="card">
      <h2>取り込みサマリー</h2>
      <div class="metrics" id="summary"></div>
      <div class="diag" id="masterDiag" style="display:none;"></div>
      <div id="preview" class="muted">（先頭50行プレビューを表示）</div>
    </div>
  </div>

  <!-- ベスレポ集計 -->
  <div id="bestTab" class="tabcontent">
    <div class="card">
      <h2>ベスレポ集計</h2>
      <div class="form-row">
        <div><label>開始日</label><input type="date" id="bestStart" /></div>
        <div><label>終了日</label><input type="date" id="bestEnd" /></div>
        <div>
          <label>ランキング軸</label>
          <select id="bestMetric">
            <option value="amt">売上順（明細金額合計）</option>
            <option value="qty">点数順（販売数量合計）</option>
            <option value="gp">粗利順（粗利合計）</option>
            <option value="uniq">購買ユニークユーザー数順</option>
            <option value="repeat">リピートユーザー数順（同一JANを2回以上）</option>
          </select>
        </div>
        <div class="btn-group">
          <button id="bestRun" class="btn">この条件で集計</button>
          <button id="bestExport" class="btn ghost" disabled>CSVエクスポート</button>
        </div>
      </div>
      <div id="bestInfo" class="muted" style="margin-bottom:8px;"></div>
      <div id="bestTable"></div>
    </div>
  </div>

  <!-- 時間帯集計 -->
  <div id="timeTab" class="tabcontent">
    <div class="card">
      <h2>時間帯集計（1時間ごと）</h2>
      <div class="form-row">
        <div><label>開始日</label><input type="date" id="timeStart" /></div>
        <div><label>終了日</label><input type="date" id="timeEnd" /></div>
        <div>
          <label>曜日</label>
          <select id="timeDow">
            <option value="all">すべて</option>
            <option value="weekday">平日</option>
            <option value="weekend">土日</option>
          </select>
        </div>
        <div>
          <label>指標</label>
          <select id="timeMetric">
            <option value="amt">売上金額（合計）</option>
            <option value="receipts">レシート件数</option>
            <option value="basket">バスケットサイズ（点数/レシート）</option>
            <option value="aov">平均客単価（売上/レシート）</option>
          </select>
        </div>
        <div class="btn-group">
          <button id="timeRun" class="btn">この条件で集計</button>
          <button id="timeExport" class="btn ghost" disabled>CSVエクスポート</button>
          <button id="timePng" class="btn ghost" disabled>PNG保存</button>
        </div>
      </div>
      <div id="timeInfo" class="muted" style="margin-bottom:8px;"></div>
      <div id="timeChart" style="height:360px;"></div>
      <div id="timeTable" style="margin-top:12px;"></div>
    </div>
  </div>

  <!-- 単品分析 -->
  <div id="prodTab" class="tabcontent">
    <div class="card">
      <h2>単品分析</h2>
      <div class="form-row">
        <div><label>開始日</label><input type="date" id="prodStart" /></div>
        <div><label>終了日</label><input type="date" id="prodEnd" /></div>
        <div><label>JANコード</label><input type="text" id="prodJan" placeholder="半角JANを入力" /></div>
        <div class="btn-group"><button id="prodRun" class="btn">この条件で集計</button></div>
      </div>
      <div id="prodHeader" class="muted" style="margin-bottom:8px;"></div>
      <div class="metrics" id="prodSummary"></div>
      <div id="prodChart" style="height:320px; margin-top:8px;"></div>
      <div id="prodDiag" class="diag" style="display:none;"></div>
    </div>
  </div>

  <!-- RFM分析（ポップアップ説明付き） -->
  <div id="rfmTab" class="tabcontent">
    <div class="card">
      <div class="hstack">
        <h2 style="margin:0;">RFM分析</h2>
        <button class="info-btn" data-modal="modalRfm" title="RFMの説明">i</button>
        <button class="info-btn" data-modal="modalScore" title="スコアリングの説明">i</button>
        <button class="info-btn" data-modal="modalSeg" title="セグメント定義">i</button>
      </div>

      <div class="form-row">
        <div><label>開始日</label><input type="date" id="rfmStart" /></div>
        <div><label>終了日</label><input type="date" id="rfmEnd" /></div>
        <div>
          <label>税率（Mは税抜換算）</label>
          <select id="rfmTax">
            <option value="0">0%（既に税抜）</option>
            <option value="10" selected>10%（税込→税抜）</option>
            <option value="8">8%（軽減）</option>
          </select>
        </div>
        <div class="btn-group">
          <button id="rfmRun" class="btn">この条件で集計</button>
          <button id="rfmExport" class="btn ghost" disabled>CSVエクスポート</button>
        </div>
      </div>

      <div id="rfmInfo" class="muted" style="margin-bottom:10px;"></div>

      <div class="grid2">
        <div id="rfmPie" style="height:320px;"></div>
        <div id="rfmScatter" style="height:320px;"></div>
      </div>

      <div id="rfmTable" style="margin-top:12px;"></div>
    </div>
  </div>

  <!-- 以降プレースホルダ -->
  <div id="segTab" class="tabcontent"><div class="card"><p class="muted">セグメント分析は後続で実装します。</p></div></div>
  <div id="repeatOnlyTab" class="tabcontent"><div class="card"><p class="muted">リピート分析は後続で実装します。</p></div></div>
  <div id="pairOnlyTab" class="tabcontent"><div class="card"><p class="muted">併売分析は後続で実装します。</p></div></div>

  <!-- === ポップアップ（モーダル） === -->
  <div id="modalRfm" class="modal"><div class="dialog">
    <span class="close" data-close="modalRfm">×</span>
    <h3>RFMの説明</h3>
    <ul>
      <li><b>R（Recency：最近性）</b> … 基準日（終了日の23:59）から最終購入日までの経過日数。小さいほど良い。</li>
      <li><b>F（Frequency：頻度）</b> … 期間内の購入回数（ユニークなレシート件数）。</li>
      <li><b>M（Monetary：金額）</b> … 期間内の購買金額合計（税抜）。</li>
    </ul>
    <p class="muted">顧客IDはCGID、日時は「生成時間」、金額は明細（商品価格×数量）をもとに算出します。</p>
  </div></div>

  <div id="modalScore" class="modal"><div class="dialog">
    <span class="close" data-close="modalScore">×</span>
    <h3>スコアリングの説明</h3>
    <p>全顧客に対する分位を用いて 1〜5 点を付与します（20/40/60/80%）。</p>
    <ul>
      <li><b>R</b>：値が小さいほど良い → 小さい方から5点、古いほど点が下がる（逆スコア）。</li>
      <li><b>F / M</b>：大きいほど良い → 大きい方から5点。</li>
    </ul>
    <p class="muted">データ件数が少ない場合は自動で3段階にフォールバックし、安定した区分になるよう調整します。</p>
  </div></div>

  <div id="modalSeg" class="modal"><div class="dialog">
    <span class="close" data-close="modalSeg">×</span>
    <h3>セグメント定義</h3>
    <ul>
      <li><b>ヘビーユーザー</b> … R≥4 かつ F≥4（かつM≥3）</li>
      <li><b>一般ユーザー</b> … R=3–4 かつ F=3（±1許容）</li>
      <li><b>ライトユーザー</b> … R≥4 かつ F≤2</li>
      <li><b>離反傾向</b> … R=2–3 かつ F≤3</li>
      <li><b>離反顧客</b> … R≤2（Fは問わず）</li>
    </ul>
    <p class="muted">まずはR×Fを主指標として簡潔な5分類。運用でチューニング可能です。</p>
  </div></div>

  <script>
    /** 固定カテゴリ（小分類）マスタURL */
    const CATEGORY_TXT_URL = "https://ppih-donki.github.io/analyze.app/data/category.txt";

    // ===== ユーティリティ =====
    const $ = (id) => document.getElementById(id);
    function toNarrow(str){
      if (str == null) return "";
      return String(str).replace(/\ufeff/g,"").replace(/\u3000/g," ")
        .replace(/[\uFF01-\uFF5E]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).trim();
    }
    function keyNorm(s){ return toNarrow(s).toLowerCase().replace(/\s+/g,""); }
    function parseCSVFile(file){
      return new Promise((resolve,reject)=>{
        Papa.parse(file, { header:true, skipEmptyLines:true, encoding:"UTF-8",
          complete: (res)=>{
            const headers = res.meta.fields.map(h=>toNarrow(h));
            const data = res.data.map(row=>{
              const o={};
              res.meta.fields.forEach((raw,i)=>{
                const normalized = headers[i];
                o[normalized] = row[raw];
              });
              return o;
            });
            resolve({ data, headers });
          }, error: reject
        });
      });
    }
    function toNumber(x, def=0){
      if (x === null || x === undefined) return def;
      let s = String(x);
      s = toNarrow(s).replace(/[^\d.\-]/g, "");
      if (!s) return def;
      const v = Number(s);
      return isNaN(v) ? def : v;
    }
    function parseDate(s){
      if(!s) return null;
      const t = toNarrow(s).replace(/\s+/g," ");
      const d = new Date(t);
      return isNaN(d.getTime()) ? null : d;
    }
    const fmtDate = (d)=> !d ? "-" : `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
    const fmtDateSlash = (d)=> !d ? "-" : `${d.getFullYear()}/${d.getMonth()+1}/${d.getDate()}`;
    const minDate = (arr)=> arr.reduce((a,r)=>(!a||r.生成時間<a? r.生成時間:a), null);
    const maxDate = (arr)=> arr.reduce((a,r)=>(!a||r.生成時間>a? r.生成時間:a), null);

    function renderTable(rows, elId, cols=null, max=null){
      const el = $(elId);
      if (!el) return;
      if (!rows || rows.length===0){ el.innerHTML = "<p class='muted'>データがありません。</p>"; return; }
      const headers = cols || Object.keys(rows[0]);
      let html = "<table><thead><tr>";
      headers.forEach(h=> html += `<th>${h}</th>`); html += "</tr></thead><tbody>";
      const view = max ? rows.slice(0, max) : rows;
      view.forEach(r=>{
        html += "<tr>";
        headers.forEach(h=> html += `<td>${r[h] ?? ""}</td>`);
        html += "</tr>";
      });
      html += "</tbody></table>";
      el.innerHTML = html;
    }

    // ===== 状態 =====
    let els = {};
    let joined = [];
    let masterMap = null;
    let categoryMap = null;

    // ベスレポ保持
    let lastBestList = null;
    let lastBestMeta = null;
    // 時間帯保持
    let lastTimeRows = null;
    let lastTimeMeta = null;
    // RFM保持
    let lastRfmRows = null;
    let lastRfmMeta = null;

    // ===== カテゴリマスタ =====
    async function autoLoadCategory(){
      const badge = els.catStatus;
      try{
        const res = await fetch(CATEGORY_TXT_URL, { mode:"cors", cache:"no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        categoryMap = parseCategoryTxt(text);
        if (badge){ badge.className="muted"; badge.textContent = "カテゴリマスタ：GitHubから読込済み"; }
      }catch(e){
        if (badge){ badge.className="error"; badge.textContent = "カテゴリtxtの取得に失敗: " + (e?.message||e); }
      }
    }
    function parseCategoryTxt(text){
      const lines = String(text).split(/\r?\n/);
      const map = new Map();
      for (const line of lines){
        const raw = toNarrow(line);
        if (!raw) continue;
        let parts = raw.split("\t");
        if (parts.length < 2) parts = raw.split(/\s+/);
        if (parts.length < 2) continue;
        const code = parts[0];
        const name = parts.slice(1).join(" ");
        if (!/^\d{3,}$/.test(code)) continue;
        map.set(code, name);
      }
      return map;
    }

    function findHeader(headers, candidates){
      const normHeaders = headers.map(h=>keyNorm(h));
      for (const cand of candidates){
        const k = keyNorm(cand);
        const idx = normHeaders.indexOf(k);
        if (idx !== -1) return headers[idx];
      }
      return null;
    }
    function buildMasterMap(pm){
      const { data: pmRows, headers } = pm;
      const map = new Map();
      const codeCands = ["商品コード","商品cd","jan","janコード","バーコード","コード"];
      const catCands  = ["商品分類","小分類","小分類コード","分類"];
      const nameCands = ["商品名","商品名規格","品名","商品名称"];
      const costCands = ["pos原価","pos 原価","ｐｏｓ原価","原価","仕入原価","pos原価(税抜)","原価(税抜)"];
      const codeHdr = findHeader(headers, codeCands);
      const catHdr  = findHeader(headers, catCands);
      const nameHdr = findHeader(headers, nameCands);
      let   costHdr = findHeader(headers, costCands);
      if (!costHdr && headers.length > 12) costHdr = headers[12]; // M列
      for (const r of pmRows){
        const code = toNarrow(codeHdr ? r[codeHdr] : "").trim();
        if (!code) continue;
        const nm   = toNarrow(nameHdr ? r[nameHdr] : "") || "";
        const cat  = toNarrow(catHdr ? r[catHdr] : "") || "";
        let cost = 0;
        if (costHdr && r.hasOwnProperty(costHdr)) cost = toNumber(r[costHdr], 0);
        map.set(code, { 商品名: nm, 商品分類: cat, POS原価: cost });
      }
      return map;
    }

    // ===== 取り込み =====
    async function runImport(){
      const statusEl = els.status; const runBtn = els.runBtn;
      if (runBtn) runBtn.disabled = true;
      if (statusEl){ statusEl.className = "muted"; statusEl.textContent = "取り込み中…"; }
      try{
        const [tx, ln] = await Promise.all([ parseCSVFile(els.txInput.files[0]), parseCSVFile(els.lnInput.files[0]) ]);
        let pm = null;
        if (els.pmInput.files.length===1) pm = await parseCSVFile(els.pmInput.files[0]);

        const txRows = tx.data, lnRows = ln.data;
        const needTx = new Set(["CGID","オーダーID","生成時間"].map(toNarrow));
        const needLn = new Set(["CGID","オーダーID","JANコード","商品名","商品数","商品価格","生成時間"].map(toNarrow));
        const hasAll=(rows,need)=> rows.length && [...need].every(c=> Object.prototype.hasOwnProperty.call(rows[0],c));
        if(!hasAll(txRows,needTx) || !hasAll(lnRows,needLn)){
          if (statusEl){ statusEl.className="error"; statusEl.textContent="必須列が不足（取引毎: CGID, オーダーID, 生成時間 / 商品毎: CGID, オーダーID, JANコード, 商品名, 商品数, 商品価格, 生成時間）"; }
          return;
        }

        txRows.forEach(r=>{ r.CGID=toNarrow(r.CGID); r.オーダーID=toNarrow(r.オーダーID); r.生成時間=parseDate(r.生成時間); });
        lnRows.forEach(r=>{
          r.CGID=toNarrow(r.CGID); r.オーダーID=toNarrow(r.オーダーID);
          r.JANコード=toNarrow(r.JANコード); r.商品名=toNarrow(r.商品名);
          r.生成時間=parseDate(r.生成時間);
          r.商品数=Math.trunc(toNumber(r.商品数,0)); r.商品価格=toNumber(r.商品価格,0);
        });

        masterMap = null;
        let masterInfoText = "商品マスタ：未読込（原価=0扱い）";
        if (pm){ masterMap = buildMasterMap(pm); masterInfoText = `商品マスタ：${pm.data.length.toLocaleString()}行（JANキー: ${masterMap.size.toLocaleString()}件）`; }

        const txMap = new Map(); txRows.forEach(r => txMap.set(`${r.CGID}||${r.オーダーID}`, r));

        joined = []; let matched=0; const unmatchedJAN = new Map();
        for(const r of lnRows){
          const key = `${r.CGID}||${r.オーダーID}`; if(!txMap.has(key)) continue;
          const txRec = txMap.get(key);
          let 商品名2=r.商品名, 商品分類="", 小分類名="", 原価=0;
          if (masterMap && masterMap.has(r.JANコード)){
            const m=masterMap.get(r.JANコード); if (m.商品名) 商品名2=m.商品名; 商品分類=m.商品分類||""; 原価=toNumber(m.POS原価,0); matched++;
          } else if (masterMap){ unmatchedJAN.set(r.JANコード,(unmatchedJAN.get(r.JANコード)||0)+1); }
          if (categoryMap && 商品分類){ 小分類名 = categoryMap.get(商品分類) || ""; }
          const 明細金額 = (r.商品価格||0) * (r.商品数||0);
          const 明細粗利 = ((r.商品価格||0)-(原価||0)) * (r.商品数||0);
          joined.push({ CGID:r.CGID, オーダーID:r.オーダーID, 生成時間:txRec.生成時間||r.生成時間,
            JANコード:r.JANコード, 商品名:商品名2, 商品分類, 小分類名,
            商品数:r.商品数, 商品価格:r.商品価格, POS原価:原価, 明細金額, 明細粗利 });
        }

        const uniqUsers = new Set(joined.map(x=>x.CGID)).size;
        const receipts  = new Set(joined.map(x=>x.オーダーID)).size;
        const totalQty  = joined.reduce((s,x)=> s + (x.商品数||0), 0);
        const totalAmt  = joined.reduce((s,x)=> s + (x.明細金額||0), 0);
        const totalGp   = joined.reduce((s,x)=> s + (x.明細粗利||0), 0);
        const dMin = minDate(joined), dMax = maxDate(joined);

        $("summary").innerHTML = `
          <div class="metric">期間: <span class="kpi-strong">${fmtDateSlash(dMin)} ~ ${fmtDateSlash(dMax)}</span></div>
          <div class="metric">ユニークユーザー数: <span class="kpi-strong">${uniqUsers.toLocaleString()}</span></div>
          <div class="metric">レシート件数: <span class="kpi-strong">${receipts.toLocaleString()}</span></div>
          <div class="metric">売上点数合計: <span class="kpi-strong">${totalQty.toLocaleString()}</span></div>
          <div class="metric">売上金額合計: <span class="kpi-strong">${totalAmt.toLocaleString()}</span></div>
          <div class="metric">粗利合計: <span class="kpi-strong">${totalGp.toLocaleString()}</span></div>
        `;
        if (dMin && dMax){
          ["best","time","prod","rfm"].forEach(prefix=>{
            $(prefix+"Start").min = $(prefix+"End").min = fmtDate(dMin);
            $(prefix+"Start").max = $(prefix+"End").max = fmtDate(dMax);
            $(prefix+"Start").value = fmtDate(dMin);
            $(prefix+"End").value   = fmtDate(dMax);
          });
        }
        const diag = $("masterDiag");
        const rate = joined.length ? Math.round((matched / joined.length) * 100) : 0;
        let topUnmatched = "";
        if (unmatchedJAN.size){
          const arr = Array.from(unmatchedJAN.entries()).sort((a,b)=> b[1]-a[1]).slice(0,10);
          topUnmatched = "<br>未マッチJAN上位: " + arr.map(([jan,c])=> `${jan}(${c})`).join(", ");
        }
        diag.style.display = "block";
        diag.innerHTML = `${masterInfoText} / 明細行: ${joined.length.toLocaleString()} / マスタ適用: ${matched.toLocaleString()}（${rate}%）${topUnmatched}`;

        renderTable(joined, "preview",
          ["CGID","オーダーID","生成時間","JANコード","商品名","商品分類","小分類名","商品数","商品価格","POS原価","明細金額","明細粗利"], 50);

        if (statusEl){ statusEl.className = "muted"; statusEl.textContent = "完了！"; }
      }catch(err){
        console.error(err);
        if (statusEl){ statusEl.className = "error"; statusEl.textContent = "エラー: " + (err?.message || String(err)); }
      }finally{
        if (runBtn) runBtn.disabled = false;
      }
    }

    // ===== ベスレポ =====
    function computeBestReport(){
      if (!joined.length){ $("bestInfo").textContent = "先にCSVを取り込んでください。"; $("bestTable").innerHTML = ""; $("bestExport").disabled = true; lastBestList=null; lastBestMeta=null; return; }
      const s = $("bestStart").value, e = $("bestEnd").value, metric = $("bestMetric").value;
      const sDate = s ? new Date(s+"T00:00:00") : null, eDate = e ? new Date(e+"T23:59:59") : null;
      const rows = joined.filter(r=> r.生成時間 && (!sDate || r.生成時間>=sDate) && (!eDate || r.生成時間<=eDate));
      const byJan = new Map();
      for (const r of rows){
        const k = r.JANコード || "-";
        if (!byJan.has(k)) byJan.set(k,{JANコード:k, 商品名:r.商品名||"", 小分類名:r.小分類名||"", 売上金額合計:0, 売上点数合計:0, 粗利合計:0, ユーザーset:new Set(), userCnt:new Map()});
        const o = byJan.get(k);
        o.売上金額合計 += (r.明細金額||0); o.売上点数合計 += (r.商品数||0); o.粗利合計 += (r.明細粗利||0);
        if (r.CGID){ o.ユーザーset.add(r.CGID); o.userCnt.set(r.CGID,(o.userCnt.get(r.CGID)||0)+(r.商品数||0)); }
      }
      const list=[]; for (const o of byJan.values()){ const repeatUsers = Array.from(o.userCnt.values()).filter(cnt=>cnt>=2).length;
        list.push({ JANコード:o.JANコード, 商品名:o.商品名, 小分類名:o.小分類名, 売上金額合計:Math.round(o.売上金額合計), 売上点数合計:Math.round(o.売上点数合計), 粗利合計:Math.round(o.粗利合計), 購買ユニークユーザー数:o.ユーザーset.size, リピートユーザー数:repeatUsers });
      }
      const keyMap={amt:"売上金額合計", qty:"売上点数合計", gp:"粗利合計", uniq:"購買ユニークユーザー数", repeat:"リピートユーザー数"};
      const labelMap={amt:"売上ベスレポ", qty:"点数ベスレポ", gp:"粗利ベスレポ", uniq:"ユニークユーザー数ベスレポ", repeat:"リピートベスレポ"};
      const sortKey = keyMap[metric] || "売上金額合計", label=labelMap[metric] || "売上ベスレポ";
      list.sort((a,b)=> b[sortKey]-a[sortKey]);
      $("bestInfo").textContent = `期間: ${s||"-"} ~ ${e||"-"} / 件数: ${list.length.toLocaleString()}`;
      renderTable(list, "bestTable", ["JANコード","商品名","小分類名","売上金額合計","売上点数合計","粗利合計","購買ユニークユーザー数","リピートユーザー数"], null);
      lastBestList=list; lastBestMeta={start:s||"",end:e||"",label}; $("bestExport").disabled = !lastBestList.length;
    }
    function exportBestCSV(){
      if (!lastBestList || !lastBestList.length) return;
      const headers=["JANコード","商品名","小分類名","売上金額合計","売上点数合計","粗利合計","購買ユニークユーザー数","リピートユーザー数"];
      const ymd=(s)=> s ? s.replaceAll("-","/") : "-"; const preface=`${ymd(lastBestMeta.start)} ~ ${ymd(lastBestMeta.end)} ${lastBestMeta.label}`;
      const lines=[preface, headers.join(",")];
      for (const r of lastBestList){
        const row=headers.map(h=>{ let v=r[h]??""; v=String(v).replaceAll('"','""'); if (/[",\n]/.test(v)) v=`"${v}"`; return v; });
        lines.push(row.join(","));
      }
      const csv="\uFEFF"+lines.join("\n"); const fn=`${lastBestMeta.start||"all"}_${lastBestMeta.end||"all"}_${lastBestMeta.label}.csv`;
      const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"}); const url=URL.createObjectURL(blob);
      const a=document.createElement("a"); a.href=url; a.download=fn; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    // ===== 時間帯集計 =====
    function computeTimeReport(){
      if (!joined.length){ $("timeInfo").textContent="先にCSVを取り込んでください。"; $("timeTable").innerHTML=""; $("timeExport").disabled=true; $("timePng").disabled=true; lastTimeRows=null; lastTimeMeta=null; Plotly.purge("timeChart"); return; }
      const s=$("timeStart").value, e=$("timeEnd").value, dow=$("timeDow").value, metric=$("timeMetric").value;
      const sDate = s ? new Date(s+"T00:00:00") : null, eDate = e ? new Date(e+"T23:59:59") : null;
      const rows = joined.filter(r=>{
        if (!r.生成時間) return false;
        const wd = r.生成時間.getDay(); const isWeekend=(wd===0||wd===6);
        if (dow==="weekday" && isWeekend) return false;
        if (dow==="weekend" && !isWeekend) return false;
        if (sDate && r.生成時間 < sDate) return false;
        if (eDate && r.生成時間 > eDate) return false;
        return true;
      });
      const buckets = Array.from({length:24},(_,h)=>({時間帯:`${String(h).padStart(2,"0")}:00`, 売上金額:0, 売上点数:0, 粗利:0, _receipts:new Set(), _users:new Set()}));
      for (const r of rows){ const h=r.生成時間.getHours(); const b=buckets[h]; b.売上金額+=(r.明細金額||0); b.売上点数+=(r.商品数||0); b.粗利+=(r.明細粗利||0); if (r.オーダーID) b._receipts.add(r.オーダーID); if (r.CGID) b._users.add(r.CGID); }
      const tableRows=buckets.map(b=>{ const rc=b._receipts.size||0; const basket=rc?(b.売上点数/rc):0; const aov=rc?(b.売上金額/rc):0;
        return {時間帯:b.時間帯, 売上金額:Math.round(b.売上金額), 売上点数:Math.round(b.売上点数), 粗利:Math.round(b.粗利), レシート件数:rc, ユニークユーザー数:b._users.size, バスケットサイズ:+basket.toFixed(2), 平均客単価:+aov.toFixed(2)}; });
      const yKeyMap={amt:"売上金額",receipts:"レシート件数",basket:"バスケットサイズ",aov:"平均客単価"}, labelMap=yKeyMap;
      const yKey=yKeyMap[metric]||"売上金額", label=labelMap[metric]||"売上金額";
      const x=buckets.map(b=>b.時間帯), y=tableRows.map(r=>r[yKey]);
      Plotly.newPlot("timeChart",[{type:"scatter",mode:"lines+markers",x,y,name:label}],{margin:{l:50,r:10,t:10,b:40},xaxis:{title:"時間帯（時）"},yaxis:{title:label,rangemode:"tozero"},displayModeBar:false},{responsive:true});
      const ranking=[...tableRows].sort((a,b)=> b[yKey]-a[yKey]);
      $("timeInfo").textContent=`期間: ${s||"-"} ~ ${e||"-"} / 曜日: ${({"all":"すべて","weekday":"平日","weekend":"土日"}[dow])} / 指標: ${label}`;
      renderTable(ranking,"timeTable",["時間帯","売上金額","売上点数","粗利","レシート件数","ユニークユーザー数","バスケットサイズ","平均客単価"],null);
      lastTimeRows=tableRows; lastTimeMeta={start:s||"",end:e||"",label:`時間帯集計（${label}）`,dow}; $("timeExport").disabled=lastTimeRows.length===0; $("timePng").disabled=false;
    }
    function exportTimeCSV(){
      if (!lastTimeRows || !lastTimeRows.length) return;
      const headers=["時間帯","売上金額","売上点数","粗利","レシート件数","ユニークユーザー数","バスケットサイズ","平均客単価"];
      const ymd=(s)=> s ? s.replaceAll("-","/") : "-"; const dowLabel={"all":"すべて","weekday":"平日","weekend":"土日"}[lastTimeMeta.dow]||"すべて";
      const preface=`${ymd(lastTimeMeta.start)} ~ ${ymd(lastTimeMeta.end)} ${lastTimeMeta.label}（${dowLabel}）`;
      const lines=[preface, headers.join(",")];
      for (const r of lastTimeRows){
        const row=headers.map(h=>{ let v=r[h]; if (v==null) v=""; v=String(v).replaceAll('"','""'); if (/[",\n]/.test(v)) v=`"${v}"`; return v; });
        lines.push(row.join(","));
      }
      const csv="\uFEFF"+lines.join("\n"); const fn=`${lastTimeMeta.start||"all"}_${lastTimeMeta.end||"all"}_${lastTimeMeta.label}.csv`;
      const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"}); const url=URL.createObjectURL(blob);
      const a=document.createElement("a"); a.href=url; a.download=fn; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }
    async function exportTimePNG(){ await Plotly.downloadImage("timeChart",{format:"png",filename:"time_series"}); }

    // ===== 単品分析 =====
    function computeProductReport(){
      if (!joined.length){ $("prodHeader").textContent="先にCSVを取り込んでください。"; $("prodSummary").innerHTML=""; Plotly.purge("prodChart"); $("prodDiag").style.display="none"; return; }
      const s=$("prodStart").value, e=$("prodEnd").value, janInput=toNarrow($("prodJan").value).replace(/\s+/g,"");
      if (!janInput){ $("prodHeader").textContent="JANコードを入力してください。"; $("prodSummary").innerHTML=""; Plotly.purge("prodChart"); $("prodDiag").style.display="none"; return; }
      const sDate=s?new Date(s+"T00:00:00"):null, eDate=e?new Date(e+"T23:59:59"):null;
      const rows=joined.filter(r=> r.生成時間 && (!sDate||r.生成時間>=sDate) && (!eDate||r.生成時間<=eDate) && (toNarrow(r.JANコード).replace(/\s+/g,"")===janInput));
      const prodName=rows[0]?.商品名 || (masterMap?.get(janInput)?.商品名) || ""; const smallCat=rows[0]?.小分類名 || "";
      $("prodHeader").innerHTML=`期間: ${s||"-"} ~ ${e||"-"} / 対象JAN: <span class="badge">${janInput}</span> ${prodName? " / 商品名: "+prodName:""} ${smallCat? " / 小分類: "+smallCat:""}`;
      if (!rows.length){ $("prodSummary").innerHTML="<p class='muted'>該当データがありません。</p>"; Plotly.purge("prodChart"); $("prodDiag").style.display="none"; return; }
      const totalQty=rows.reduce((s,x)=>s+(x.商品数||0),0), totalAmt=rows.reduce((s,x)=>s+(x.明細金額||0),0), totalGp=rows.reduce((s,x)=>s+(x.明細粗利||0),0);
      const uuSet=new Set(rows.map(x=> x.CGID).filter(Boolean)); const cntByUser=new Map(); rows.forEach(r=> cntByUser.set(r.CGID,(cntByUser.get(r.CGID)||0)+(r.商品数||0)) );
      const repeatUsers=Array.from(cntByUser.values()).filter(v=>v>=2).length;
      $("prodSummary").innerHTML=`
        <div class="metric">売上点数合計: <span class="kpi-strong">${Math.round(totalQty).toLocaleString()}</span></div>
        <div class="metric">売上金額合計: <span class="kpi-strong">${Math.round(totalAmt).toLocaleString()}</span></div>
        <div class="metric">粗利額合計: <span class="kpi-strong">${Math.round(totalGp).toLocaleString()}</span></div>
        <div class="metric">ユニーク購入者数: <span class="kpi-strong">${uuSet.size.toLocaleString()}</span></div>
        <div class="metric">リピート購入者数: <span class="kpi-strong">${repeatUsers.toLocaleString()}</span></div>`;
      const buckets=Array.from({length:24},(_,h)=>({h,qty:0})); rows.forEach(r=>{ const h=r.生成時間.getHours(); buckets[h].qty+=(r.商品数||0); });
      Plotly.newPlot("prodChart",[{type:"bar", x:buckets.map(b=>String(b.h).padStart(2,"0")+":00"), y:buckets.map(b=>Math.round(b.qty)), name:"売上点数（時間帯）"}],
        {margin:{l:50,r:10,t:10,b:40},xaxis:{title:"時間帯（時）"},yaxis:{title:"売上点数",rangemode:"tozero"},displayModeBar:false},{responsive:true});
      const receiptSet=new Set(rows.map(r=>r.オーダーID)); const dMin=minDate(rows), dMax=maxDate(rows);
      $("prodDiag").style.display="block"; $("prodDiag").innerHTML=`明細行: ${rows.length.toLocaleString()} / レシート: ${receiptSet.size.toLocaleString()} / 最小日時: ${fmtDateSlash(dMin)} / 最大日時: ${fmtDateSlash(dMax)}`;
    }

    // ===== RFM =====
    function quantiles(arr, qs){
      const a = arr.slice().sort((x,y)=>x-y);
      const res = [];
      for (const q of qs){
        if (a.length===0){ res.push(0); continue; }
        const pos = (a.length-1)*q;
        const base = Math.floor(pos), rest = pos - base;
        const v = a[base] + (a[Math.min(base+1,a.length-1)] - a[base]) * rest;
        res.push(v);
      }
      return res;
    }
    function scoreByQuantile(value, cuts, reverse=false){
      if (cuts.length===2){
        if (!reverse){ if (value <= cuts[0]) return 1; if (value <= cuts[1]) return 3; return 5; }
        else         { if (value <= cuts[0]) return 5; if (value <= cuts[1]) return 3; return 1; }
      }
      if (!reverse){
        if (value <= cuts[0]) return 1;
        if (value <= cuts[1]) return 2;
        if (value <= cuts[2]) return 3;
        if (value <= cuts[3]) return 4;
        return 5;
      }else{
        if (value <= cuts[0]) return 5;
        if (value <= cuts[1]) return 4;
        if (value <= cuts[2]) return 3;
        if (value <= cuts[3]) return 2;
        return 1;
      }
    }
    function rfmSegmentName(r,f,m){
      if (r>=4 && f>=4 && m>=3) return "ヘビーユーザー";
      if (r>=4 && f<=2) return "ライトユーザー";
      if (r<=2) return "離反顧客";
      if (r>=3 && f>=3) return "一般ユーザー";
      return "離反傾向";
    }
    function computeRFM(){
      if (!joined.length){ $("rfmInfo").textContent="先にCSVを取り込んでください。"; $("rfmTable").innerHTML=""; $("rfmExport").disabled=true; Plotly.purge("rfmPie"); Plotly.purge("rfmScatter"); lastRfmRows=null; lastRfmMeta=null; return; }
      const s=$("rfmStart").value, e=$("rfmEnd").value, taxRateSel=Number($("rfmTax").value||"0");
      const sDate=s?new Date(s+"T00:00:00"):null, eDate=e?new Date(e+"T23:59:59"):null;
      const rows=joined.filter(r=> r.生成時間 && (!sDate||r.生成時間>=sDate) && (!eDate||r.生成時間<=eDate));
      if (!rows.length){ $("rfmInfo").textContent="該当データがありません。"; $("rfmTable").innerHTML=""; $("rfmExport").disabled=true; Plotly.purge("rfmPie"); Plotly.purge("rfmScatter"); lastRfmRows=[]; return; }

      // レシート集約（F/R用）
      const receiptMap = new Map(); // key: CGID||オーダーID
      for (const r of rows){
        const key=`${r.CGID}||${r.オーダーID}`;
        if (!receiptMap.has(key)) receiptMap.set(key,{ CGID:r.CGID, オーダーID:r.オーダーID, 金額:0, 時刻:r.生成時間 });
        const o=receiptMap.get(key);
        o.金額 += (r.明細金額||0);
        if (r.生成時間 && (!o.時刻 || r.生成時間>o.時刻)) o.時刻=r.生成時間;
      }
      // 顧客集計（Mは税抜換算）
      const byUser = new Map();
      const taxDiv = taxRateSel>0 ? (1+taxRateSel/100) : 1;
      for (const r of rows){
        const k=r.CGID||"-"; if (!byUser.has(k)) byUser.set(k,{ CGID:k, M:0, GM:0, last:null });
        const u=byUser.get(k);
        const lineEx = (r.明細金額||0) / taxDiv;
        u.M += lineEx;
        u.GM += (r.明細粗利||0);
        if (!u.last || r.生成時間>u.last) u.last=r.生成時間;
      }
      // F: レシート件数
      for (const rec of receiptMap.values()){
        if (!byUser.has(rec.CGID)) byUser.set(rec.CGID,{CGID:rec.CGID,M:0,GM:0,last:null});
        const u=byUser.get(rec.CGID);
        u.F = (u.F||0)+1;
      }
      const baseDate = eDate || maxDate(rows) || new Date();
      const list=[];
      for (const u of byUser.values()){
        if (!u.F) u.F=0;
        if (!u.last) continue;
        const days = Math.max(0, Math.floor((baseDate - u.last)/(1000*60*60*24)));
        list.push({ CGID:u.CGID, R_days:days, F:u.F, M: u.M, GM: u.GM, last_date: u.last });
      }
      if (!list.length){ $("rfmInfo").textContent="対象顧客がありません。"; $("rfmTable").innerHTML=""; $("rfmExport").disabled=true; Plotly.purge("rfmPie"); Plotly.purge("rfmScatter"); lastRfmRows=[]; return; }

      // 分位（全顧客に対する分位）
      const n=list.length;
      let cutsR, cutsF, cutsM;
      if (n<100){
        cutsR = quantiles(list.map(x=>x.R_days), [1/3, 2/3]);
        cutsF = quantiles(list.map(x=>x.F),      [1/3, 2/3]);
        cutsM = quantiles(list.map(x=>x.M),      [1/3, 2/3]);
      }else{
        cutsR = quantiles(list.map(x=>x.R_days), [0.2,0.4,0.6,0.8]);
        cutsF = quantiles(list.map(x=>x.F),      [0.2,0.4,0.6,0.8]);
        cutsM = quantiles(list.map(x=>x.M),      [0.2,0.4,0.6,0.8]);
      }

      const rowsOut=[];
      for (const x of list){
        const Rs = scoreByQuantile(x.R_days, cutsR, true);
        const Fs = scoreByQuantile(x.F,      cutsF, false);
        const Ms = scoreByQuantile(x.M,      cutsM, false);
        const seg = rfmSegmentName(Rs, Fs, Ms);
        rowsOut.push({
          CGID: x.CGID,
          R（日数）: x.R_days,
          F（回）: x.F,
          M（税抜合計）: Math.round(x.M),
          GM（粗利合計）: Math.round(x.GM),
          Rスコア: Rs, Fスコア: Fs, Mスコア: Ms,
          セグメント: seg,
          最終購入日: fmtDateSlash(x.last_date)
        });
      }

      $("rfmInfo").textContent=`期間: ${s||"-"} ~ ${e||"-"} / 顧客数: ${rowsOut.length.toLocaleString()} / 税率: ${taxRateSel}%`;

      // 円グラフ（セグメント分布）
      const segCount = {};
      for (const r of rowsOut){ segCount[r.セグメント]=(segCount[r.セグメント]||0)+1; }
      const segLabels = Object.keys(segCount);
      const segValues = segLabels.map(k=>segCount[k]);
      Plotly.newPlot("rfmPie", [{ type:"pie", labels:segLabels, values:segValues, hole:0.35 }], { margin:{l:10,r:10,t:20,b:10}, showlegend:true }, {responsive:true});

      // 散布図（R×F、サイズ=M）
      Plotly.newPlot("rfmScatter", [{
        x: rowsOut.map(r=> r["R（日数）"]),
        y: rowsOut.map(r=> r["F（回）"]),
        text: rowsOut.map(r=> `${r.CGID} / M=${r["M（税抜合計）"]}`),
        mode:"markers",
        marker:{ size: rowsOut.map(r=> Math.max(6, Math.min(24, r["M（税抜合計）"]/Math.max(1, (cutsM[0]||1)))) ) },
        type:"scatter",
        transforms:[{ type:"groupby", groups: rowsOut.map(r=> r.セグメント) }],
      }], { margin:{l:50,r:10,t:10,b:40}, xaxis:{title:"R（日数・小さいほど良）", rangemode:"tozero"}, yaxis:{title:"F（回）", rangemode:"tozero"} }, {responsive:true});

      renderTable(rowsOut, "rfmTable", ["CGID","R（日数）","F（回）","M（税抜合計）","GM（粗利合計）","Rスコア","Fスコア","Mスコア","セグメント","最終購入日"], null);

      lastRfmRows = rowsOut;
      lastRfmMeta = { start:s||"", end:e||"", label:"RFM（税抜）", tax: taxRateSel };
      $("rfmExport").disabled = rowsOut.length===0;
    }
    function exportRFM(){
      if (!lastRfmRows || !lastRfmRows.length) return;
      const headers = ["CGID","R（日数）","F（回）","M（税抜合計）","GM（粗利合計）","Rスコア","Fスコア","Mスコア","セグメント","最終購入日"];
      const ymd=(s)=> s ? s.replaceAll("-","/") : "-";
      const preface = `${ymd(lastRfmMeta.start)} ~ ${ymd(lastRfmMeta.end)} ${lastRfmMeta.label}（税率=${lastRfmMeta.tax}%）`;
      const lines=[preface, headers.join(",")];
      for (const r of lastRfmRows){
        const row = headers.map(h=>{ let v=r[h]; if (v==null) v=""; v=String(v).replaceAll('"','""'); if (/[",\n]/.test(v)) v=`"${v}"`; return v; });
        lines.push(row.join(","));
      }
      const csv="\uFEFF"+lines.join("\n"); const fn=`${lastRfmMeta.start||"all"}_${lastRfmMeta.end||"all"}_RFM.csv`;
      const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"}); const url=URL.createObjectURL(blob);
      const a=document.createElement("a"); a.href=url; a.download=fn; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    // ===== UI配線 =====
    function updateButton(){
      const ok = (els.txInput?.files?.length===1 && els.lnInput?.files?.length===1);
      if (els.runBtn) els.runBtn.disabled = !ok;
      if (els.status){
        els.status.className = "muted";
        els.status.textContent = ok ? "準備OK。取り込み＆集計できます。" : "CSVを2つ選択してください";
      }
      $("fnameTx").textContent = els.txInput?.files?.[0]?.name || "未選択";
      $("fnameTx").classList.toggle("muted", !els.txInput?.files?.length);
      $("fnameLn").textContent = els.lnInput?.files?.[0]?.name || "未選択";
      $("fnameLn").classList.toggle("muted", !els.lnInput?.files?.length);
      $("fnamePm").textContent = els.pmInput?.files?.[0]?.name || "未選択";
      $("fnamePm").classList.toggle("muted", !els.pmInput?.files?.length);
    }
    function onTabClick(t){
      document.querySelectorAll(".tab,.tabcontent").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      const pane = document.getElementById(t.dataset.tab);
      if (pane) pane.classList.add("active");
    }
    function bindModals(){
      document.querySelectorAll(".info-btn").forEach(btn=>{
        btn.addEventListener("click", ()=>{ const id=btn.getAttribute("data-modal"); const m=$(id); if(m) m.style.display="block"; });
      });
      document.querySelectorAll(".modal .close").forEach(x=>{
        x.addEventListener("click", ()=>{ const id=x.getAttribute("data-close"); const m=$(id); if(m) m.style.display="none"; });
      });
      window.addEventListener("click", (e)=>{ if (e.target.classList.contains("modal")) e.target.style.display="none"; });
    }

    // ===== 初期化 =====
    document.addEventListener("DOMContentLoaded", async ()=>{
      els = {
        txInput: $("txFile"),
        lnInput: $("lnFile"),
        pmInput: $("pmFile"),
        runBtn: $("runBtn"),
        status: $("status"),
        catStatus: $("catStatus"),
      };
      // label for=... で選択するため、.click() 配線は不要。change でUI更新のみ。
      els.txInput?.addEventListener("change", updateButton);
      els.lnInput?.addEventListener("change", updateButton);
      els.pmInput?.addEventListener("change", updateButton);

      // タブ
      document.querySelectorAll(".tab").forEach(t=> t.addEventListener("click", ()=> onTabClick(t)));
      bindModals();

      // カテゴリマスタ
      await autoLoadCategory();

      // 取り込み
      els.runBtn?.addEventListener("click", runImport);

      // ベスレポ
      $("bestRun")?.addEventListener("click", computeBestReport);
      $("bestExport")?.addEventListener("click", exportBestCSV);

      // 時間帯
      $("timeRun")?.addEventListener("click", computeTimeReport);
      $("timeExport")?.addEventListener("click", exportTimeCSV);
      $("timePng")?.addEventListener("click", async ()=>{ await Plotly.downloadImage("timeChart",{format:"png",filename:"time_series"}); });

      // 単品
      $("prodRun")?.addEventListener("click", computeProductReport);

      // RFM
      $("rfmRun")?.addEventListener("click", computeRFM);
      $("rfmExport")?.addEventListener("click", exportRFM);

      // 初期
      updateButton();
    });
  </script>
</body>
</html>
