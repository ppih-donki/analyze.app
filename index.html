<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>小売ダッシュボード (完全クライアント)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- PyScript (Pyodide) -->
  <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
  <script defer src="https://pyscript.net/latest/pyscript.js"></script>
  <!-- Plotly.js (グラフ表示用；CDN。データは送信されません) -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .full { grid-column: 1 / -1; }
    .btn { background: #111827; color: #fff; padding: 8px 12px; border-radius: 8px; border: none; cursor: pointer; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    label { font-weight: 600; display:block; margin-bottom: 6px; }
    input[type="file"] { padding: 8px; border: 1px solid #e5e7eb; border-radius: 8px; width: 100%; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; }
    .muted { color: #6b7280; font-size: 12px; }
  </style>
</head>
<body>
  <h1>小売ダッシュボード（完全クライアント）</h1>
  <p class="muted">データはブラウザ内でのみ処理され、サーバーへ送信されません。</p>

  <div class="card row">
    <div>
      <label>取引毎.csv（レシート情報）</label>
      <input id="txFile" type="file" accept=".csv" />
    </div>
    <div>
      <label>商品毎.csv（単品明細）</label>
      <input id="lnFile" type="file" accept=".csv" />
    </div>
    <div class="full">
      <label>（任意）商品マスタ product_master.csv（JAN, 商品名, 商品分類）</label>
      <input id="pmFile" type="file" accept=".csv" />
    </div>
    <div class="full">
      <button id="runBtn" class="btn" disabled>取り込み & 集計（RFMまで）</button>
      <span id="status" class="muted" style="margin-left:8px;">CSVを2つ選択してください</span>
    </div>
  </div>

  <div class="card">
    <h2>取り込み結果（プレビュー）</h2>
    <div id="preview"></div>
  </div>

  <div class="card row">
    <div id="rfmTable" class="full"></div>
    <div id="segPie" class="full" style="height:420px;"></div>
  </div>

  <py-config>
    packages = ["pandas"]
  </py-config>

  <py-script>
from js import document, FileReader, console, Plotly
import pandas as pd
import io, asyncio

# ==== ユーティリティ ====
def read_csv_file(file_obj, encodings=("utf-8-sig","cp932","utf-8")):
    """ブラウザのFileオブジェクトをPython側で読み、pandasへ"""
    reader = FileReader.new()
    done = asyncio.get_event_loop().create_future()

    def onload(_):
        done.set_result(reader.result)

    reader.onload = onload
    reader.readAsText(file_obj)

    # 待機
    js_text = await done
    text = str(js_text)

    # エンコーディング順に試行（pandasは文字列IOからencoding未指定でもOKだが互換のため）
    for enc in encodings:
        try:
            df = pd.read_csv(io.StringIO(text))
            return df
        except Exception as e:
            continue
    # 最後の手段
    return pd.read_csv(io.StringIO(text))

def normalize_columns(df):
    # 余分な空白・全角→半角コロン等はサンプル前提で最小限
    def norm(s):
        s = str(s).replace("\ufeff","").strip()
        return s
    df.columns = [norm(c) for c in df.columns]
    return df

def parse_datetime_series(s):
    # "2025/8/5  21:53:13" のようにスペース2個でもOKにする
    ss = s.astype(str).str.strip().str.replace(r"\s+", " ", regex=True)
    # 和暦や他形式は想定外、ISO系に寄せる
    # 2025/8/5 21:53:13 等に対応
    return pd.to_datetime(ss, errors="coerce")

def rfm_from_joined(df_join):
    # 基準日はデータの最新  + 1日
    ref = df_join["生成時間"].max() + pd.Timedelta(days=1)
    rfm = df_join.groupby("CGID").agg(
        Recency日=("生成時間", lambda x: (ref - x.max()).days),
        Frequency回数=("オーダーID", "nunique"),
        Monetary金額=("明細金額", "sum"),
    ).reset_index()

    # スコア（百分位を4分位）
    def score(series, asc_good):
        r = series.rank(method="average", pct=True)
        if asc_good:
            r = 1 - r
        bins = [0.0, 0.25, 0.50, 0.75, 1.0]
        labels = [1,2,3,4]
        return pd.cut(r.fillna(0.0), bins=bins, labels=labels, include_lowest=True).astype(int)

    rfm["Rスコア"] = score(rfm["Recency日"], asc_good=True)
    rfm["Fスコア"] = score(rfm["Frequency回数"], asc_good=False)
    rfm["Mスコア"] = score(rfm["Monetary金額"], asc_good=False)
    rfm["RFMスコア"] = rfm["Rスコア"] + rfm["Fスコア"] + rfm["Mスコア"]

    # 簡易セグメント
    def seg(r,f,m,t):
        if r>=3 and f>=3 and m>=3: return "ロイヤル"
        if r>=3 and (f>=3 or m>=3): return "優良"
        if r>=3 and f<=2 and m<=2: return "新規/育成"
        if r==1 and (f>=3 or m>=3): return "離反懸念"
        if r==1 and f<=2 and m<=2: return "休眠"
        if t>=10: return "準ロイヤル"
        if t>=7: return "一般"
        return "要観察"
    rfm["セグメント"] = [seg(r,f,m,t) for r,f,m,t in zip(rfm["Rスコア"], rfm["Fスコア"], rfm["Mスコア"], rfm["RFMスコア"])]
    return rfm

def render_table(df, el_id, max_rows=50):
    el = document.getElementById(el_id)
    if df.empty:
        el.innerHTML = "<p class='muted'>データがありません。</p>"
        return
    html = "<table><thead><tr>"
    for c in df.columns:
        html += f"<th>{c}</th>"
    html += "</tr></thead><tbody>"
    for _, row in df.head(max_rows).iterrows():
        html += "<tr>" + "".join(f"<td>{row[c]}</td>" for c in df.columns) + "</tr>"
    html += "</tbody></table>"
    el.innerHTML = html

def render_seg_pie(rfm):
    counts = rfm["セグメント"].value_counts().sort_values(ascending=False)
    data = [dict(labels=list(counts.index), values=list(counts.values), type="pie", hole=0.45)]
    layout = dict(title="セグメント構成（人数）", margin=dict(l=24,r=24,t=40,b=24))
    Plotly.newPlot("segPie", data, layout, {"displayModeBar": False})

# ==== UI結線 ====
txInput = document.getElementById("txFile")
lnInput = document.getElementById("lnFile")
pmInput = document.getElementById("pmFile")
runBtn  = document.getElementById("runBtn")
status  = document.getElementById("status")

def update_button_state(*args, **kwargs):
    runBtn.disabled = not (txInput.files.length == 1 and lnInput.files.length == 1)
    status.innerText = "準備OK。取り込み＆集計できます。" if not runBtn.disabled else "CSVを2つ選択してください"

txInput.addEventListener("change", update_button_state)
lnInput.addEventListener("change", update_button_state)

async def on_run_click(evt):
    runBtn.disabled = True
    status.innerText = "取り込み中..."
    try:
        # 1) 取込
        tx_df = await read_csv_file(txInput.files.item(0))
        ln_df = await read_csv_file(lnInput.files.item(0))
        tx_df = normalize_columns(tx_df)
        ln_df = normalize_columns(ln_df)

        # 必須列チェック
        need_tx = {"CGID","オーダーID","生成時間"}
        need_ln = {"CGID","オーダーID","JANコード","商品名","商品数","商品価格","生成時間"}
        if not need_tx.issubset(set(tx_df.columns)):
            missing = need_tx - set(tx_df.columns)
            status.innerText = f"取引毎.csv の必須列が不足: {missing}"
            return
        if not need_ln.issubset(set(ln_df.columns)):
            missing = need_ln - set(ln_df.columns)
            status.innerText = f"商品毎.csv の必須列が不足: {missing}"
            return

        # 2) 型＆日付整形
        for c in ["CGID","オーダーID","JANコード","商品名"]:
            if c in ln_df.columns: ln_df[c] = ln_df[c].astype("string").str.strip()
        for c in ["CGID","オーダーID"]:
            tx_df[c] = tx_df[c].astype("string").str.strip()
        ln_df["商品数"]   = pd.to_numeric(ln_df["商品数"], errors="coerce").fillna(0).astype(int)
        ln_df["商品価格"] = pd.to_numeric(ln_df["商品価格"], errors="coerce").fillna(0.0)

        tx_df["生成時間"] = parse_datetime_series(tx_df["生成時間"])
        ln_df["生成時間"] = parse_datetime_series(ln_df["生成時間"])

        # 3) マスタ（任意）
        if pmInput.files.length == 1:
            pm_df = await read_csv_file(pmInput.files.item(0))
            pm_df = normalize_columns(pm_df)
            # 想定: 商品コード, 商品分類, 商品名
            colmap = { "商品コード":"JANコード", "商品名":"マスタ商品名", "商品分類":"商品分類" }
            for src, dst in colmap.items():
                if src in pm_df.columns:
                    pm_df = pm_df.rename(columns={src: dst})
            if "JANコード" in pm_df.columns:
                pm_df["JANコード"] = pm_df["JANコード"].astype("string").str.strip()
                ln_df = ln_df.merge(pm_df[["JANコード","マスタ商品名","商品分類"]], on="JANコード", how="left")
                # マスタ名があればそちら優先
                ln_df["商品名"] = ln_df["マスタ商品名"].combine_first(ln_df["商品名"])
                ln_df.drop(columns=[c for c in ["マスタ商品名"] if c in ln_df.columns], inplace=True)

        # 4) JOIN（CGID, オーダーID で）
        joined = ln_df.merge(tx_df[["CGID","オーダーID","生成時間","オーダー金額"]] if "オーダー金額" in tx_df.columns else tx_df[["CGID","オーダーID","生成時間"]],
                             on=["CGID","オーダーID"], how="inner", suffixes=("","_tx"))
        # 明細金額 = 単価×数量
        joined["明細金額"] = joined["商品価格"] * joined["商品数"]

        # 5) プレビュー
        render_table(joined[["CGID","オーダーID","生成時間","JANコード","商品名","商品数","商品価格","明細金額"]], "preview", max_rows=30)

        # 6) RFM
        rfm = rfm_from_joined(joined)
        render_table(rfm.sort_values("RFMスコア", ascending=False).head(50), "rfmTable", max_rows=50)
        render_seg_pie(rfm)

        status.innerText = "完了！"
    except Exception as e:
        status.innerText = f"エラー: {e}"
    finally:
        runBtn.disabled = False

document.getElementById("runBtn").addEventListener("click", on_run_click)
  </py-script>
</body>
</html>
